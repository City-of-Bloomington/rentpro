package rental.utils;
import java.io.*;
import java.util.List;
import java.util.ArrayList;
import org.xml.sax.*;
import org.xml.sax.helpers.DefaultHandler;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import java.net.URL;
import java.security.KeyStore;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.util.EntityUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import rental.list.*;
import rental.model.*;

public class HandleTypes extends DefaultHandler{

    // connect to legaltrack to get the list
    static String stUrl = "";
    final static long serialVersionUID = 360L;
    boolean outFlag = false, debug = true; // true will print the input
    private Writer out = null;
    String lineEnd = null;
    List<CaseType> types = null;
    CaseType caseType = null;
    String currElem = "";
    static Logger logger = LogManager.getLogger(HandleTypes.class);
	
    public HandleTypes(String strUrl, boolean debug){

	super();
	outFlag = debug;
	debug = debug;
        // Use an instance of ourselves as the SAX event handler
	//
	DefaultHandler handler = this;
	// Use the default (non-validating) parser
	SAXParserFactory factory = SAXParserFactory.newInstance();
	//
	DefaultHttpClient httpclient = new DefaultHttpClient();	
	try {
	    if(strUrl == null || strUrl.equals(""))
		strUrl = stUrl;
	    if(debug)
		logger.debug(strUrl);
	    HttpGet httpget = new HttpGet(strUrl);
            HttpResponse response = httpclient.execute(httpget);
            HttpEntity entity = response.getEntity();
	    InputStream ret = entity.getContent();
	    //
	    out = new OutputStreamWriter(System.out, "UTF8");
	    lineEnd =  System.getProperty("line.separator");
	    //
	    // Parse the input
	    //
	    SAXParser saxParser = factory.newSAXParser();
	    saxParser.parse(ret, handler);

	} catch (SAXParseException spe) {
	    // Error generated by the parser
	    logger.error("\n** Parsing error" 
			 + ", line " + spe.getLineNumber()
			 + ", uri " + spe.getSystemId());
	    logger.error("   " + spe.getMessage() );
	} catch (Exception ex) {
	    logger.error(""+ex);
	}	
    }
    public List<CaseType> getTypes(){
	return types;
    }

    public InputStream readUrl(String strUrl) throws Exception {
		
	URL url = new URL(strUrl);
        InputStream is = url.openStream();
        return is;
    }
    //
    // not used
    //
    public String readUrl2(String strUrl) throws Exception {

	URL url = new URL(strUrl);
	InputStream is = url.openStream();
	BufferedReader in = new BufferedReader (new InputStreamReader(is));
	StringBuffer sb = new StringBuffer();
	String line = null;
	while ((line = in.readLine()) != null) {
	    // System.err.println(line);
	    sb.append(line);
	    sb.append("\n");
	}
	return sb.toString();
    }
	
    //===========================================================
    // SAX DocumentHandler methods
    //===========================================================

    public void startDocument() throws SAXException{

        emit("<?xml version='1.0' encoding='UTF-8'?>");
        nl();
	types = new ArrayList<CaseType>();
    }

    public void endDocument() throws SAXException {
        try {
            nl();
            out.flush();
        } catch (IOException e) {
	    logger.error(e);			
            throw new SAXException("I/O error", e);
        }
    }

    public void startElement(String namespaceURI,
                             String lName, // local name
                             String qName, // qualified name
                             Attributes attrs)
	throws SAXException{

        String eName = lName; // element name
        if ("".equals(eName)) eName = qName; // namespaceAware = false
	currElem = qName;
	if(qName.equals("type"))
	    caseType = new CaseType(debug);
        emit("<"+eName);
        if (attrs != null) {
            for (int i = 0; i < attrs.getLength(); i++) {
                String aName = attrs.getLocalName(i); // Attr name 
                if ("".equals(aName)) aName = attrs.getQName(i);
                emit(" ");
                emit(aName+"=\""+attrs.getValue(i)+"\"");
            }
        }
        emit(">");
    }
    ///
    public void endElement(String namespaceURI,
                           String sName, // simple name
                           String qName  // qualified name
			   ) throws SAXException {
        emit("</"+qName+">");
	if(qName.equals("type"))
	    types.add(caseType);
    }
    ///
    public void characters(char buf[], int offset, int len)
	throws SAXException{
        String s = new String(buf, offset, len);
        emit(s);
	s = s.trim();
	if(!s.equals("")){
	    if(currElem.equals("id"))
		caseType.setId(s);
	    else if(currElem.equals("description"))
		caseType.setDesc(s);			
	}
    }

    //===========================================================
    // Utility Methods ...
    //===========================================================
    //
    // Wrap I/O exceptions in SAX exceptions, to
    // suit handler signature requirements
    //
    private void emit(String s) throws SAXException{

        try {
	    if(outFlag){
		out.write(s);
		out.flush();
	    }
	} catch (IOException e) {
	    logger.error(e);			
	    throw new SAXException("I/O error", e);
	}
    }

    // Start a new line
    private void nl() throws SAXException{

        try {
	    if(outFlag){
		out.write(lineEnd);
	    }
        } catch (IOException e) {
	    logger.error(e);			
            throw new SAXException("I/O error", e);
        }
    }

}







































